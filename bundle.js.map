{"version":3,"sources":["webpack:///webpack/bootstrap 6cee74da68902176ac1c","webpack:///./lib/main.js","webpack:///./lib/sudoku.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE,uCAAuC;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO,oEAAoE;AAC3E,2BAA2B;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,oCAAoC;AACpE,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,gCAAgC,GAAG,GAAG,EAAE;AACxC;AACA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA;AACA,0BAA0B,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,2BAA2B,aAAa;AACxC;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,4BAA4B,gDAAgD;AAC5E,0BAA0B,qCAAqC;AAC/D,uCAAuC,qCAAqC;AAC5E,6BAA6B,qCAAqC;AAClE,6BAA6B,+DAA+D;AAC5F,gCAAgC,2CAA2C;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB,uBAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrRA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD,mBAAmB,EAAE;AACrB,8DAA8D,YAAY;AAC1E,cAAc,EAAE,GAAG,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6cee74da68902176ac1c","import SudokuBoard from './sudoku';\n// import $ from 'jquery';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const game = new SudokuGame();\n});\n\nclass SudokuGame {\n  constructor() {\n    this.setUpSudoku = this.setUpSudoku.bind(this);\n    this.setUpGrid = this.setUpGrid.bind(this);\n    this.setUpNumberPanel = this.setUpNumberPanel.bind(this);\n    this.setUpOptionsPanel = this.setUpOptionsPanel.bind(this);\n    this.gridProportions = this.gridProportions.bind(this);\n    this.isTargetInClass = this.isTargetInClass.bind(this);\n    this.dragOver = this.dragOver.bind(this);\n    this.dragEnter = this.dragOver.bind(this);\n    this.dragLeave = this.dragOver.bind(this);\n    this.drop = this.drop.bind(this);\n\n\n    this.setUpSudoku();\n    this.selectedCell = $(\".sudoku-cell\").first();\n    this.selectedButton = $(\".number-button\").first();\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n    this.selectedCell.addClass(\"selected\");\n\n    $(window).resize(this.gridProportions);\n\n    $(\".number-button\").on(\"click\", (e) => {\n      this.selectedButton.removeClass(\"selected\");\n      this.selectedButton = $(e.currentTarget);\n      this.selectedButton.addClass(\"selected\");\n      let cell = this.board.cells[parseInt(this.selectedCell.attr(\"id\"))];\n      if (cell.isGiven) {return;}\n      let num = parseInt(this.selectedButton.attr(\"val\"));\n      cell.valueVisible = true;\n      cell.possibles = [false,false,false,false,false,false,false,false,false];\n      cell.currentValue = num;\n      this.board.render();\n    });\n\n    $(\".sudoku-cell\").on(\"click\", (e) => {\n      this.selectedCell.removeClass(\"selected\");\n      this.selectedCell = $(e.currentTarget);\n      this.selectedId = parseInt(this.selectedCell.attr('id'));\n      this.selectedCell.addClass(\"selected\");\n    });\n\n    document.addEventListener(\"keydown\", (e) => {\n      let num = parseInt(e.keyCode) - 48;\n      let cell = this.board.cells[parseInt(this.selectedCell.attr(\"id\"))];\n      if (num >= 1 && num <= 9) {\n        if (cell.isGiven) {return;}\n        if (e.shiftKey) {\n          cell.value = 0;\n          cell.valueVisible = false;\n          cell.possibles[num - 1] = !cell.possibles[num - 1];\n          // for (let i = 0, len = cell.possibles.length; i < len; i++) {\n          //   if (cell.possibles[i]) {return;}\n          // }\n          // cell.valueVisible = true;\n        } else {\n          cell.valueVisible = true;\n          cell.possibles = [false,false,false,false,false,false,false,false,false];\n          cell.currentValue = num;\n        }\n        this.board.render();\n      } else if (e.keyCode === 37 && this.selectedId % 9 !== 0) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId - 1}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 39 && this.selectedId % 9 !== 8) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId + 1}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 38 && Math.floor(this.selectedId / 9) !== 0) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId - 9}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 40 && Math.floor(this.selectedId / 9) !== 8) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId + 9}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 8 || e.keyCode === 32 || e.keyCode === 48) { //delete value\n        if (cell.isGiven) {return;}\n        cell.currentValue = 0;\n        if (cell.valueVisible) {\n          cell.valueVisible = false;\n        } else {\n          cell.possibles = [false,false,false,false,false,false,false,false,false];\n        }\n        this.board.render();\n      }\n    });\n\n    document.addEventListener(\"dragstart\",(e) => {\n      let target = this.isTargetInClass(e, \"number-button\");\n      if (target === null) {return;}\n      let cell = this.board.cells[parseInt($(e.target).attr(\"id\"))];\n      this.selectedButton.removeClass(\"selected\");\n      this.selectedButton = $(target);\n      // this.selectedButton.addClass(\"selected\");\n      // let draggable = $(document.createElement(\"div\"));\n      // draggable.attr(\"id\",\"draggable-tile\");\n      // draggable.html(target.innerText);\n      // $(\"body\").append(draggable);\n    });\n\n    document.addEventListener(\"drag\", (e) => {\n      e.preventDefault();\n      $(\"#draggable-tile\").css({\"top\": e.clientY, \"left\": e.clientX});\n    });\n\n    document.addEventListener(\"dragend\", (e) => {\n      $(\"#draggable-tile\").remove();\n    });\n\n\n    $(\".sudoku-cell\").on(\"dragover\", this.dragOver);\n    $(\".sudoku-cell\").on(\"dragenter\", this.dragEnter);\n    $(\".sudoku-cell\").on(\"drop\", this.drop);\n    $(\".sudoku-cell\").on(\"dragleave\", this.dragLeave);\n\n    this.board = new SudokuBoard();\n\n\n  }\n\n  setUpSudoku() {\n    $(\"#board\").children().remove();\n    let gameSpace = $(document.createElement(\"main\"));\n    gameSpace.attr(\"id\", \"game-space\");\n    $(\"#board\").append(gameSpace);\n    this.setUpGrid();\n    this.setUpNumberPanel();\n    this.setUpOptionsPanel();\n    this.gridProportions();\n  }\n\n  setUpGrid() {\n    let grid = $(document.createElement(\"div\"));\n    grid.attr(\"id\", \"grid\");\n    for (let i = 0; i < 9; i++) {\n      let box = $(document.createElement(\"div\"));\n      for (let j = 0; j < 9; j++) {\n        let cell = $(document.createElement(\"div\"));\n        let possibilities = $(document.createElement(\"div\"));\n        possibilities.addClass(\"sudoku-cell-possibilities\");\n        for (let k = 0; k < 9; k++) {\n          let possible = $(document.createElement(\"div\"));\n          possible.addClass(\"sudoku-cell-possibility\");\n          let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n          possible.attr('id',`${id}-${k}`);\n          possibilities.append(possible);\n        }\n        // possibilities.attr('id',`possibilities-${id}`);\n        cell.append(possibilities);\n        cell.addClass(\"sudoku-cell\");\n        let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n        cell.attr('id',`${id}`);\n        box.append(cell);\n      }\n      box.addClass(\"sudoku-box\");\n      grid.append(box);\n    }\n    $(\"#game-space\").append(grid);\n  }\n\n  setUpNumberPanel() {\n    let numberPanel = $(document.createElement(\"div\"));\n    numberPanel.attr(\"id\", \"number-panel\");\n    let number;\n    for (let i = 0; i < 10; i++) {\n      number = $(document.createElement(\"div\"));\n      number.addClass(\"number-button\");\n      number.attr(\"val\",`${(i + 1) % 10}`);\n      number.attr(\"draggable\",true);\n      number.text(`${ (i + 1) % 10}`);\n      if ( i === 9) {\n        number.text(``);\n      }\n      numberPanel.append(number);\n    }\n    $(\"#game-space\").append(numberPanel);\n  }\n\n  gridProportions() {\n    let side =  Math.max(Math.floor(Math.min($(window).height() * 0.8, $(window).width() * 0.9)), 400);\n    side -= (side % 9);\n    $(\"#grid\").css({\"height\": side, \"width\": side});\n    $(\"#number-panel\").css({\"height\": side, \"width\": Math.floor(0.1 * side)});\n    $(\".sudoku-box\").css({\"font-size\": Math.floor(side * 0.09)});\n    $(\".sudoku-cell-possibility\").css({\"font-size\": Math.floor(side * 0.03)});\n    $(\".number-button\").css({\"font-size\": Math.floor(side * 0.08)});\n    $(\".option-button\").css({\"width\": Math.floor((side + Math.floor(side * 0.08) + 32) / 4)});\n    // $(\"#options-panel\").css({\"margin-left\": $(\"#grid\").offset()[\"left\"]});\n  }\n\n  setUpOptionsPanel() {\n    let optionsPanel = $(document.createElement(\"div\"));\n    optionsPanel.attr(\"id\", \"options-panel\");\n    let option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"new-puzzle-button\");\n    option.html(\"NEW\");\n    option.on(\"click\", () => {this.board.clear(true);this.board.makeGame();});\n    optionsPanel.append(option);\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"clear-button\");\n    option.html(\"CLEAR\");\n    option.on(\"click\", () => (this.board.clear(false)));\n    optionsPanel.append(option);\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"hint-button\");\n    option.html(\"HINT\");\n    optionsPanel.append(option);\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"check-submit-button\");\n    option.html(\"CHECK\");\n    optionsPanel.append(option);\n    $(\"#board\").append(optionsPanel);\n  }\n\n  isTargetInClass(e, className) {\n    let target = e.target;\n    while (target.parentElement !== null) {\n      if (target.className === className) {\n        return target;\n      }\n      target = target.parentElement;\n    }\n    return null;\n  }\n\n  dragOver(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let target = $(e.target);\n    this.selectedCell.removeClass(\"selected\");\n    this.selectedCell = target;\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n    this.selectedCell.addClass(\"selected\");\n  }\n\n  dragLeave(e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  dragEnter(e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  drop(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let target = $(e.target);\n    let cell = this.board.cells[parseInt(target.attr(\"id\"))];\n    if (!cell.isGiven) {\n      let num = parseInt(this.selectedButton.attr(\"val\"));\n      cell.valueVisible = true;\n      cell.possibles = [false,false,false,false,false,false,false,false,false];\n      cell.currentValue = num;\n      this.board.render();\n    }\n    this.selectedCell = target;\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 0\n// module chunks = 0","// import $ from 'jquery';\n\nfunction shuffle(array) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  while (0 !== currentIndex) {\n\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nclass SudokuBoard {\n  constructor() {\n    this.boxes = [];\n    this.cells = [];\n    for (let i = 0; i < 9; i++) {\n      this.boxes.push(new SudokuBox(i));\n    }\n    let boxIdx, sudokuCell;\n    for (let i = 0; i < 81; i++) {\n      sudokuCell = new SudokuCell(0, i, false);\n      this.cells.push(sudokuCell);\n      boxIdx = (Math.floor(i / 27) * 3) + Math.floor((i % 9) / 3);\n      sudokuCell.box = this.boxes[boxIdx];\n      this.boxes[boxIdx].cells.push(sudokuCell);\n    }\n    this.render = this.render.bind(this);\n    this.setup = this.setup.bind(this);\n    this.populate = this.populate.bind(this);\n    this.populateBoard = this.populateBoard.bind(this);\n    this.changeNeighborsPos = this.changeNeighborsPos.bind(this);\n    this.changeNeighborsPosStep = this.changeNeighborsPosStep.bind(this);\n    this.solve = this.solve.bind(this);\n    this.solveCycle = this.solveCycle.bind(this);\n    this.resolveAmbiguity = this.resolveAmbiguity.bind(this);\n    this.getLeastAmbiguousCell = this.getLeastAmbiguousCell.bind(this);\n    this.depopulate = this.depopulate.bind(this);\n    this.setCellPossibilities = this.setCellPossibilities.bind(this);\n    this.makeGame = this.makeGame.bind(this);\n    this.clear = this.clear.bind(this);\n\n    this.makeGame();\n  }\n\n  render() {\n    let cell, children, possibilities;\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      cell = $(`#${i}`);\n      for (let j = 0, posLen = this.cells[i].possibles.length; j < posLen; j++) {\n        $(`#${i}-${j}`).text(this.cells[i].possibles[j] ? j + 1 : \"\");\n      }\n      children = cell.children();\n      cell.text(this.cells[i].currentValue !== 0 && this.cells[i].valueVisible ? this.cells[i].currentValue : \"\");\n      cell.append(children);\n      if (this.cells[i].valueVisible) {\n        cell.children().removeClass(\"visible\");\n        cell.children().addClass(\"hidden\");\n      } else {\n        cell.children().removeClass(\"hidden\");\n        cell.children().addClass(\"visible\");\n      }\n    }\n  }\n\n  makeGame(){\n    this.solvedGrid = this.populateBoard();\n    this.depopulate(60);\n    this.setCellPossibilities();\n    let puzzle = new Array(this.cells.length);\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      puzzle[i] = this.cells[i].currentValue;\n    }\n    puzzle = this.solve(puzzle);\n    this.setup(puzzle);\n  }\n\n  clear(givens) {\n    for (let i = 0, len = this.cells.length; i <len; i++) {\n      if (givens || !this.cells[i].isGiven) {\n        this.cells[i].currentValue = 0;\n        this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n        this.cells[i].isGiven = false;\n        this.cells[i].inConflict = false;\n        $(`#${i}`).removeClass(\"given\");\n      }\n    }\n    this.render();\n  }\n\n  setup(puzzle) {\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      if (puzzle[i] > 0) {\n        this.cells[i].isGiven = true;\n        $(`#${i}`).addClass(\"given\");\n      }\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n      this.cells[i].currentValue = puzzle[i];\n    }\n    this.render();\n  }\n\n  populateBoard() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [0,0,0,0,0,0,0,0,0];\n    }\n    while (true) {\n      if (this.populate(0)){\n        break;\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n    }\n    let solvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      solvedGrid[i] = this.cells[i].currentValue;\n    }\n    return solvedGrid;\n  }\n\n  populate(cellIdx) {\n    if (cellIdx >= 81) {\n      return true;\n    }\n    let indii = new Array(9);\n    let cell = this.cells[cellIdx];\n    for (let i = 0, len = indii.length; i < len; i++) {\n      indii[i] = i;\n    }\n    indii = shuffle(indii);\n    for (let i = 0, len = cell.possibles.length; i < len; i++) {\n      let posIdx = indii[i];\n      if (cell.possibles[posIdx]) {\n        continue;\n      }\n\n      cell.currentValue = posIdx + 1;\n      this.changeNeighborsPosStep(cellIdx, posIdx, 1);\n\n      if (this.populate(cellIdx + 1)) {\n        return true;\n      } else {\n        this.changeNeighborsPosStep(cellIdx, posIdx, -1);\n        this.currentValue = 0;\n      }\n    }\n    return false;\n  }\n\n  depopulate(num) {\n    let idxs = [];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue !== 0){\n        idxs.push(i);\n      }\n    }\n    idxs = shuffle(idxs);\n    for (let i = 0, len = Math.min(num, this.cells.length); i < len; i++) {\n      this.cells[idxs.pop()].currentValue = 0;\n    }\n  }\n\n  changeNeighborsPos(cellIdx, posIdx, value) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] = value;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] = value;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] = value;\n    }\n  }\n\n  changeNeighborsPosStep(cellIdx, posIdx, step) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] += step;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] += step;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] += step;\n    }\n  }\n\n  setCellPossibilities() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [true,true,true,true,true,true,true,true,true];\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n        this.cells[i].isGiven = true;\n        this.changeNeighborsPos(i, this.cells[i].currentValue - 1, false);\n      }\n    }\n  }\n\n  solve() {\n    //store initial state of grid\n    //call solve, and store the state that it returns\n    //if solve finished, reset to initial state and return true\n    //if unsolved, get cell with least ambiguity and cycle through guesses, calling solve after each\n    //if solve returns true only once, reset to inital state and return true\n    //else, reset to initial state and return false\n    let unsolvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = unsolvedGrid.length; i < len; i++) {\n      unsolvedGrid[i] = this.cells[i].currentValue;\n    }\n    let grid = this.solveCycle(unsolvedGrid);\n    let cell, givenCell, possibles;\n    while (grid.includes(0)) {\n      cell = this.getLeastAmbiguousCell();\n      possibles = cell.getPossibles();\n      while (possibles.length > 1) {\n        givenCell = this.resolveAmbiguity(cell, possibles[0], Math.floor(Math.random() * 3));\n        unsolvedGrid[givenCell.idx] = possibles[0] + 1;\n        possibles = cell.getPossibles();\n      }\n\n      grid = this.solveCycle(grid);\n    }\n    return unsolvedGrid;\n    //alternatively, if solve is unfinished, get least ambiguous cell and fill in cells until unambigious\n    //these would also have to be filled in in the initial state\n  }\n\n  getLeastAmbiguousCell() {\n    let idx = 0;\n    while (this.cells[idx].currentValue > 0) {\n      idx += 1;\n    }\n    let cell = this.cells[idx];\n    let minPossibles = cell.getPossibles().length;\n    let possibles;\n    for (let i = 1, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        continue;\n      }\n      possibles = this.cells[i].getPossibles().length;\n      if (possibles < minPossibles) {\n        cell = this.cells[i];\n        minPossibles = possibles;\n      }\n    }\n    return cell;\n  }\n\n  resolveAmbiguity(cell, num, dir = 0) {\n    let targetCell;\n    if ( dir === 0) { // get cell from box\n      for (let i = 0, len = cell.box.cells.length; i < len; i++) {\n        if (this.solvedGrid[cell.box.cells[i].idx] === num + 1 ) {\n          targetCell = cell.box.cells[i];\n          break;\n        }\n      }\n    } else if (dir === 1) { //get cell from row\n      let startRow = Math.floor(cell.idx / 9) * 9;\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[startRow + i] === num + 1 ){\n          targetCell = this.cells[startRow+i];\n          break;\n        }\n      }\n    } else { //get cell from col\n      let startCol = Math.floor(cell.idx % 9);\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[(9 * i) + startCol] === num + 1) {\n          targetCell = this.cells[(9 * i) + startCol];\n          break;\n        }\n      }\n    }\n    this.changeNeighborsPos(targetCell.idx, num, false);\n    targetCell.currentValue = num + 1;\n    targetCell.possibles = [false,false,false,false,false,false,false,false,false];\n    return targetCell;\n  }\n\n  solveCycle(state) {\n    let newState = state.slice();\n    let possiblesIdx;\n    let foundValue = true;\n    let solutions;\n    while (foundValue) {\n      foundValue = false;\n      for (let i = 0, len = this.cells.length; i < len; i++) {\n        if (this.cells[i].isGiven) {\n          continue;\n        }\n        possiblesIdx = this.cells[i].getPossibles();\n        if (possiblesIdx.length === 1) {\n          this.cells[i].currentValue = possiblesIdx[0] + 1;\n          this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(i, possiblesIdx[0], false);\n          foundValue = true;\n        }\n      }\n      for (let i = 0, len = this.boxes.length; i <len; i++) {\n        solutions = this.boxes[i].checkForSolutions();\n        for (let j = 0, solsLen = solutions.length; j < solsLen; j++) {\n          solutions[j][0].currentValue = solutions[j][1];\n          solutions[j][0].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(solutions[j][0].idx, solutions[j][1] - 1, false);\n          foundValue = true;\n        }\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      newState[i] = this.cells[i].currentValue;\n    }\n    return newState;\n    //cycle through grid, get all cells with one possible value\n    //set all selected cells to possible value\n    //repeat until no cells have single value or solved\n  }\n}\n\nclass SudokuBox {\n  constructor(idx) {\n    this.idx = idx;\n    this.cells = [];\n    this.box = null;\n  }\n\n  checkForSolutions() {\n    let nums = [0,0,0,0,0,0,0,0,0];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        nums[this.cells[i].currentValue - 1] = 1;\n      }\n    }\n    let blanks = [];\n    for (let i = 0, len = nums.length; i < len; i++) {\n      if (!nums[i]){\n        blanks.push(i);\n      }\n    }\n    let solutions = [];\n    let cell;\n    for (let i = 0, len = blanks.length; i < len; i++) {\n      cell = null;\n      for (let j = 0, cellsLen = this.cells.length; j < cellsLen; j++) {\n        if (this.cells[j].possibles[blanks[i]]) {\n          if (cell !== null) {\n            cell = -1;\n            break;\n          }\n          cell = this.cells[j];\n        }\n      }\n      if (cell !== -1 && cell !== null) {\n        solutions.push([cell, blanks[i] + 1]);\n      }\n    }\n    return solutions;\n    //will get all missing nums, and insert them if they can only be put in one place\n  }\n}\n\nclass SudokuCell {\n  constructor(value = 0, idx, isGiven) {\n    this.currentValue = value;\n    this.valueVisible = true;\n    this.idx = idx;\n    this.isGiven = isGiven;\n    this.inConflict = false;\n    this.possibles = [false,false,false,false,false,false,false,false,false];\n\n    this.togglePossible = this.togglePossible.bind(this);\n    this.getPossibles = this.getPossibles.bind(this);\n  }\n\n  togglePossible(idx) {\n    this.possibles[idx] = !this.possibles[idx];\n  }\n\n  getPossibles() {\n    let possiblesIdx = [];\n    for (let i = 0, len = this.possibles.length; i < len; i++) {\n      if (this.possibles[i]) {\n        possiblesIdx.push(i);\n      }\n    }\n    return possiblesIdx;\n  }\n}\n\n\nexport default SudokuBoard;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/sudoku.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}