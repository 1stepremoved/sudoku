{"version":3,"sources":["webpack:///webpack/bootstrap ea352dedb331db4f5b15","webpack:///./lib/main.js","webpack:///./lib/sudoku.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE,qCAAqC;AACrC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,KAAK;AACL;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,KAAK;AACL;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,KAAK;AACL;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,KAAK,oEAAoE;AACzE,yBAAyB;AACzB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,8BAA8B,GAAG,GAAG,EAAE;AACtC;AACA;AACA,kDAAkD,GAAG;AACrD;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,yBAAyB,aAAa;AACtC,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,8BAA8B;AAChD,0BAA0B,gDAAgD;AAC1E;;;;;;;;AChIA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD,mBAAmB,EAAE;AACrB,8DAA8D,YAAY;AAC1E,cAAc,EAAE,GAAG,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ea352dedb331db4f5b15","import SudokuBoard from './sudoku';\n// import $ from 'jquery';\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=> {\n  setupSudoku();\n  let selectedCell = $(\".sudoku-cell\").first();\n  let selectedButton = $(\".number-button\").first();\n  let selectedId = parseInt(selectedCell.attr('id'));\n  selectedCell.addClass(\"selected\");\n  $(\".number-button\").on(\"click\", (e) => {\n    selectedButton.removeClass(\"selected\");\n    selectedButton = $(e.currentTarget);\n    selectedButton.addClass(\"selected\");\n    let cell = board.cells[parseInt(selectedCell.attr(\"id\"))];\n    let num = parseInt(selectedButton.attr(\"val\"));\n    cell.valueVisible = true;\n    cell.possibles = [false,false,false,false,false,false,false,false,false];\n    cell.currentValue = num;\n    board.render();\n  });\n\n  $(\".sudoku-cell\").on(\"click\", (e) => {\n    selectedCell.removeClass(\"selected\");\n    selectedCell = $(e.currentTarget);\n    selectedId = parseInt(selectedCell.attr('id'));\n    selectedCell.addClass(\"selected\");\n  });\n  document.addEventListener(\"keydown\", (e) => {\n    let num = parseInt(e.keyCode) - 48;\n    let cell = board.cells[parseInt(selectedCell.attr(\"id\"))];\n    if (num >= 1 && num <= 9) {\n      if (cell.isGiven) {return;}\n      if (e.shiftKey) {\n        cell.value = 0;\n        cell.valueVisible = false;\n        cell.possibles[num - 1] = !cell.possibles[num - 1];\n        // for (let i = 0, len = cell.possibles.length; i < len; i++) {\n        //   if (cell.possibles[i]) {return;}\n        // }\n        // cell.valueVisible = true;\n      } else {\n        cell.valueVisible = true;\n        cell.possibles = [false,false,false,false,false,false,false,false,false];\n        cell.currentValue = num;\n      }\n      board.render();\n    } else if (e.keyCode === 37 && selectedId % 9 !== 0) {\n      selectedCell.removeClass(\"selected\");\n      selectedCell = $(`#${selectedId - 1}`);\n      selectedId = parseInt(selectedCell.attr('id'));\n      selectedCell.addClass(\"selected\");\n    } else if (e.keyCode === 39 && selectedId % 9 !== 8) {\n      selectedCell.removeClass(\"selected\");\n      selectedCell = $(`#${selectedId + 1}`);\n      selectedId = parseInt(selectedCell.attr('id'));\n      selectedCell.addClass(\"selected\");\n    } else if (e.keyCode === 38 && Math.floor(selectedId / 9) !== 0) {\n      selectedCell.removeClass(\"selected\");\n      selectedCell = $(`#${selectedId - 9}`);\n      selectedId = parseInt(selectedCell.attr('id'));\n      selectedCell.addClass(\"selected\");\n    } else if (e.keyCode === 40 && Math.floor(selectedId / 9) !== 8) {\n      selectedCell.removeClass(\"selected\");\n      selectedCell = $(`#${selectedId + 9}`);\n      selectedId = parseInt(selectedCell.attr('id'));\n      selectedCell.addClass(\"selected\");\n    } else if (e.keyCode === 8 || e.keyCode === 32 || e.keyCode === 48) { //delete value\n      if (cell.isGiven) {return;}\n      cell.currentValue = 0;\n      if (cell.valueVisible) {\n        cell.valueVisible = false;\n      } else {\n        cell.possibles = [false,false,false,false,false,false,false,false,false];\n      }\n      board.render();\n    }\n  });\n\n  const board = new SudokuBoard();\n});\n\nconst setupSudoku = () => {\n  $(\"#board\").children().remove();\n  let grid = $(document.createElement(\"div\"));\n  grid.attr(\"id\", \"grid\");\n  for (let i = 0; i < 9; i++) {\n    let box = $(document.createElement(\"div\"));\n    for (let j = 0; j < 9; j++) {\n      let cell = $(document.createElement(\"div\"));\n      let possibilities = $(document.createElement(\"div\"));\n      possibilities.addClass(\"sudoku-cell-possibilities\");\n      for (let k = 0; k < 9; k++) {\n        let possible = $(document.createElement(\"div\"));\n        possible.addClass(\"sudoku-cell-possibility\");\n        let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n        possible.attr('id',`${id}-${k}`);\n        possibilities.append(possible);\n      }\n      // possibilities.attr('id',`possibilities-${id}`);\n      cell.append(possibilities);\n      cell.addClass(\"sudoku-cell\");\n      let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n      cell.attr('id',`${id}`);\n      box.append(cell);\n    }\n    box.addClass(\"sudoku-box\");\n    grid.append(box);\n  }\n  $(\"#board\").append(grid);\n\n  let numberPanel = $(document.createElement(\"div\"));\n  numberPanel.attr(\"id\", \"number-panel\");\n  let number;\n  for (let i = 0; i < 10; i++) {\n    number = $(document.createElement(\"div\"));\n    number.addClass(\"number-button\");\n    number.attr(\"val\",`${(i + 1) % 10}`);\n    number.text(`${ (i + 1) % 10}`);\n    if ( i === 9) {\n      number.text(``);\n    }\n    numberPanel.append(number);\n  }\n  $(\"#board\").append(numberPanel);\n\n  let side =  Math.floor(Math.min($(window).height() * 0.8, $(window).width() * 0.9));\n  $(\"#grid\").css({\"height\": side, \"width\": side});\n  $(\"#number-panel\").css({\"height\": side, \"width\": Math.floor(0.1 * side)});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 0\n// module chunks = 0","// import $ from 'jquery';\n\nfunction shuffle(array) {\n  var currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nclass SudokuBoard {\n  constructor() {\n    this.boxes = [];\n    this.cells = [];\n    for (let i = 0; i < 9; i++) {\n      this.boxes.push(new SudokuBox(i));\n    }\n    let boxIdx, sudokuCell;\n    for (let i = 0; i < 81; i++) {\n      sudokuCell = new SudokuCell(0, i, false);\n      this.cells.push(sudokuCell);\n      boxIdx = (Math.floor(i / 27) * 3) + Math.floor((i % 9) / 3);\n      sudokuCell.box = this.boxes[boxIdx];\n      this.boxes[boxIdx].cells.push(sudokuCell);\n    }\n    this.render = this.render.bind(this);\n    this.setup = this.setup.bind(this);\n    this.populate = this.populate.bind(this);\n    this.populateBoard = this.populateBoard.bind(this);\n    this.changeNeighborsPos = this.changeNeighborsPos.bind(this);\n    this.changeNeighborsPosStep = this.changeNeighborsPosStep.bind(this);\n    this.solve = this.solve.bind(this);\n    this.solveCycle = this.solveCycle.bind(this);\n    this.resolveAmbiguity = this.resolveAmbiguity.bind(this);\n    this.getLeastAmbiguousCell = this.getLeastAmbiguousCell.bind(this);\n    this.depopulate = this.depopulate.bind(this);\n    this.setCellPossibilities = this.setCellPossibilities.bind(this);\n\n    this.solvedGrid = this.populateBoard();\n    this.depopulate(60);\n    this.setCellPossibilities();\n    let puzzle = new Array(this.cells.length);\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      puzzle[i] = this.cells[i].currentValue;\n    }\n    puzzle = this.solve(puzzle);\n    this.setup(puzzle);\n  }\n\n  render() {\n    let cell, children, possibilities;\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      cell = $(`#${i}`);\n      for (let j = 0, posLen = this.cells[i].possibles.length; j < posLen; j++) {\n        $(`#${i}-${j}`).text(this.cells[i].possibles[j] ? j + 1 : \"\");\n      }\n      children = cell.children();\n      cell.text(this.cells[i].currentValue !== 0 && this.cells[i].valueVisible ? this.cells[i].currentValue : \"\");\n      cell.append(children);\n      if (this.cells[i].valueVisible) {\n        cell.children().removeClass(\"visible\");\n        cell.children().addClass(\"hidden\");\n      } else {\n        cell.children().removeClass(\"hidden\");\n        cell.children().addClass(\"visible\");\n      }\n    }\n  }\n\n  setup(puzzle) {\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      if (puzzle[i] > 0) {\n        this.cells[i].isGiven = true;\n        $(`#${i}`).addClass(\"given\");\n      }\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n      this.cells[i].currentValue = puzzle[i];\n    }\n    this.render();\n  }\n\n  populateBoard() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [0,0,0,0,0,0,0,0,0];\n    }\n    while (true) {\n      if (this.populate(0)){\n        break;\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n    }\n    let solvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      solvedGrid[i] = this.cells[i].currentValue;\n    }\n    return solvedGrid;\n  }\n\n  populate(cellIdx) {\n    if (cellIdx >= 81) {\n      return true;\n    }\n    let indii = new Array(9);\n    let cell = this.cells[cellIdx];\n    for (let i = 0, len = indii.length; i < len; i++) {\n      indii[i] = i;\n    }\n    indii = shuffle(indii);\n    for (let i = 0, len = cell.possibles.length; i < len; i++) {\n      let posIdx = indii[i];\n      if (cell.possibles[posIdx]) {\n        continue;\n      }\n\n      cell.currentValue = posIdx + 1;\n      this.changeNeighborsPosStep(cellIdx, posIdx, 1);\n\n      if (this.populate(cellIdx + 1)) {\n        return true;\n      } else {\n        this.changeNeighborsPosStep(cellIdx, posIdx, -1);\n        this.currentValue = 0;\n      }\n    }\n    return false;\n  }\n\n  depopulate(num) {\n    let idxs = [];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue !== 0){\n        idxs.push(i);\n      }\n    }\n    idxs = shuffle(idxs);\n    for (let i = 0, len = Math.min(num, this.cells.length); i < len; i++) {\n      this.cells[idxs.pop()].currentValue = 0;\n    }\n  }\n\n  changeNeighborsPos(cellIdx, posIdx, value) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] = value;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] = value;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] = value;\n    }\n  }\n\n  changeNeighborsPosStep(cellIdx, posIdx, step) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] += step;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] += step;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] += step;\n    }\n  }\n\n  setCellPossibilities() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [true,true,true,true,true,true,true,true,true];\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n        this.cells[i].isGiven = true;\n        this.changeNeighborsPos(i, this.cells[i].currentValue - 1, false);\n      }\n    }\n  }\n\n  solve() {\n    //store initial state of grid\n    //call solve, and store the state that it returns\n    //if solve finished, reset to initial state and return true\n    //if unsolved, get cell with least ambiguity and cycle through guesses, calling solve after each\n    //if solve returns true only once, reset to inital state and return true\n    //else, reset to initial state and return false\n    let unsolvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = unsolvedGrid.length; i < len; i++) {\n      unsolvedGrid[i] = this.cells[i].currentValue;\n    }\n    let grid = this.solveCycle(unsolvedGrid);\n    let cell, givenCell, possibles;\n    while (grid.includes(0)) {\n      cell = this.getLeastAmbiguousCell();\n      possibles = cell.getPossibles();\n      while (possibles.length > 1) {\n        givenCell = this.resolveAmbiguity(cell, possibles[0], Math.floor(Math.random() * 3));\n        unsolvedGrid[givenCell.idx] = possibles[0] + 1;\n        possibles = cell.getPossibles();\n      }\n\n      grid = this.solveCycle(grid);\n    }\n    return unsolvedGrid;\n    //alternatively, if solve is unfinished, get least ambiguous cell and fill in cells until unambigious\n    //these would also have to be filled in in the initial state\n  }\n\n  getLeastAmbiguousCell() {\n    let idx = 0;\n    while (this.cells[idx].currentValue > 0) {\n      idx += 1;\n    }\n    let cell = this.cells[idx];\n    let minPossibles = cell.getPossibles().length;\n    let possibles;\n    for (let i = 1, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        continue;\n      }\n      possibles = this.cells[i].getPossibles().length;\n      if (possibles < minPossibles) {\n        cell = this.cells[i];\n        minPossibles = possibles;\n      }\n    }\n    return cell;\n  }\n\n  resolveAmbiguity(cell, num, dir = 0) {\n    let targetCell;\n    if ( dir === 0) { // get cell from box\n      for (let i = 0, len = cell.box.cells.length; i < len; i++) {\n        if (this.solvedGrid[cell.box.cells[i].idx] === num + 1 ) {\n          targetCell = cell.box.cells[i];\n          break;\n        }\n      }\n    } else if (dir === 1) { //get cell from row\n      let startRow = Math.floor(cell.idx / 9) * 9;\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[startRow + i] === num + 1 ){\n          targetCell = this.cells[startRow+i];\n          break;\n        }\n      }\n    } else { //get cell from col\n      let startCol = Math.floor(cell.idx % 9);\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[(9 * i) + startCol] === num + 1) {\n          targetCell = this.cells[(9 * i) + startCol];\n          break;\n        }\n      }\n    }\n    this.changeNeighborsPos(targetCell.idx, num, false);\n    targetCell.currentValue = num + 1;\n    targetCell.possibles = [false,false,false,false,false,false,false,false,false];\n    return targetCell;\n  }\n\n  solveCycle(state) {\n    let newState = state.slice();\n    let possiblesIdx;\n    let foundValue = true;\n    let solutions;\n    while (foundValue) {\n      foundValue = false;\n      for (let i = 0, len = this.cells.length; i < len; i++) {\n        if (this.cells[i].isGiven) {\n          continue;\n        }\n        possiblesIdx = this.cells[i].getPossibles();\n        if (possiblesIdx.length === 1) {\n          this.cells[i].currentValue = possiblesIdx[0] + 1;\n          this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(i, possiblesIdx[0], false);\n          foundValue = true;\n        }\n      }\n      for (let i = 0, len = this.boxes.length; i <len; i++) {\n        solutions = this.boxes[i].checkForSolutions();\n        for (let j = 0, solsLen = solutions.length; j < solsLen; j++) {\n          solutions[j][0].currentValue = solutions[j][1];\n          solutions[j][0].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(solutions[j][0].idx, solutions[j][1] - 1, false);\n          foundValue = true;\n        }\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      newState[i] = this.cells[i].currentValue;\n    }\n    return newState;\n    //cycle through grid, get all cells with one possible value\n    //set all selected cells to possible value\n    //repeat until no cells have single value or solved\n  }\n}\n\nclass SudokuBox {\n  constructor(idx) {\n    this.idx = idx;\n    this.cells = [];\n    this.box = null;\n  }\n\n  checkForSolutions() {\n    let nums = [0,0,0,0,0,0,0,0,0];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        nums[this.cells[i].currentValue - 1] = 1;\n      }\n    }\n    let blanks = [];\n    for (let i = 0, len = nums.length; i < len; i++) {\n      if (!nums[i]){\n        blanks.push(i);\n      }\n    }\n    let solutions = [];\n    let cell;\n    for (let i = 0, len = blanks.length; i < len; i++) {\n      cell = null;\n      for (let j = 0, cellsLen = this.cells.length; j < cellsLen; j++) {\n        if (this.cells[j].possibles[blanks[i]]) {\n          if (cell !== null) {\n            cell = -1;\n            break;\n          }\n          cell = this.cells[j];\n        }\n      }\n      if (cell !== -1 && cell !== null) {\n        solutions.push([cell, blanks[i] + 1]);\n      }\n    }\n    return solutions;\n    //will get all missing nums, and insert them if they can only be put in one place\n  }\n}\n\nclass SudokuCell {\n  constructor(value = 0, idx, isGiven) {\n    this.currentValue = value;\n    this.valueVisible = true;\n    this.idx = idx;\n    this.isGiven = isGiven;\n    this.inConflict = false;\n    this.possibles = [false,false,false,false,false,false,false,false,false];\n\n    this.togglePossible = this.togglePossible.bind(this);\n    this.getPossibles = this.getPossibles.bind(this);\n  }\n\n  togglePossible(idx) {\n    this.possibles[idx] = !this.possibles[idx];\n  }\n\n  getPossibles() {\n    let possiblesIdx = [];\n    for (let i = 0, len = this.possibles.length; i < len; i++) {\n      if (this.possibles[i]) {\n        possiblesIdx.push(i);\n      }\n    }\n    return possiblesIdx;\n  }\n}\n\n\nexport default SudokuBoard;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/sudoku.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}