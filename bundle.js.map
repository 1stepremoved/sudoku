{"version":3,"sources":["webpack:///webpack/bootstrap c339be14e4bb15b6a6bb","webpack:///./lib/main.js","webpack:///./lib/sudoku.js","webpack:///./lib/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE,uCAAuC;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO;AACP;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA,OAAO,oEAAoE;AAC3E,2BAA2B;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,oCAAoC;AACpE,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,gCAAgC,GAAG,GAAG,EAAE;AACxC;AACA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA;AACA,0BAA0B,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,2BAA2B,aAAa;AACxC;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,4BAA4B,gDAAgD;AAC5E,0BAA0B,sCAAsC;AAChE,uCAAuC,qCAAqC;AAC5E,6BAA6B,qCAAqC;AAClE;AACA,8BAA8B,+DAA+D;AAC7F,OAAO;AACP,iCAAiC,mBAAmB;AACpD,iCAAiC,qCAAqC;AACtE;AACA,gCAAgC,2CAA2C;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;;AAEA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,4DAA4D,qBAAqB;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3VA;AAAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD,8BAA8B;AAC/E;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD,mBAAmB,EAAE;AACrB,8DAA8D,YAAY;AAC1E,cAAc,EAAE,GAAG,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD,YAAY,EAAE;AACd,YAAY,EAAE;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,yCAAyC,YAAY;AACrD,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,GAAG;AACf,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA,qBAAqB,SAAS;AAC9B,wBAAwB;AACxB,cAAc;;AAEd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,OAAO;AACP,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,OAAO;AACP,cAAc,SAAS;AACvB;AACA,KAAK;AACL,YAAY,SAAS;AACrB;AACA;AACA;;;AAGA;;;;;;;;ACnjBA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c339be14e4bb15b6a6bb","import SudokuBoard from './sudoku';\n// import $ from 'jquery';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const game = new SudokuGame();\n  var touchsupport = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n  if (!touchsupport){ // browser doesn't support touch\n      document.documentElement.className += \" non-touch\";\n  }\n});\n\nclass SudokuGame {\n  constructor() {\n    this.setUpSudoku = this.setUpSudoku.bind(this);\n    this.setUpGrid = this.setUpGrid.bind(this);\n    this.setUpNumberPanel = this.setUpNumberPanel.bind(this);\n    this.setUpOptionsPanel = this.setUpOptionsPanel.bind(this);\n    this.gridProportions = this.gridProportions.bind(this);\n    this.isTargetInClass = this.isTargetInClass.bind(this);\n    this.dragOver = this.dragOver.bind(this);\n    this.dragEnter = this.dragOver.bind(this);\n    this.dragLeave = this.dragOver.bind(this);\n    this.drop = this.drop.bind(this);\n    this.check = this.check.bind(this);\n    this.newPuzzle = this.newPuzzle.bind(this);\n\n\n    this.setUpSudoku();\n    this.selectedCell = $(\".sudoku-cell\").first();\n    this.selectedButton = $(\".number-button\").first();\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n    this.selectedCell.addClass(\"selected\");\n\n    $(window).resize(this.gridProportions);\n\n    $(\".number-button\").on(\"click\", (e) => {\n      this.selectedButton.removeClass(\"selected\");\n      this.selectedButton = $(e.currentTarget);\n      this.selectedButton.addClass(\"selected\");\n      let cell = this.board.cells[parseInt(this.selectedCell.attr(\"id\"))];\n      if (cell.isGiven) {return;}\n      let num = parseInt(this.selectedButton.attr(\"val\"));\n      cell.valueVisible = true;\n      cell.possibles = [false,false,false,false,false,false,false,false,false];\n      cell.currentValue = num;\n      if (parseInt(this.selectedButton.attr(\"val\")) === 0 && this.selectedCell.hasClass(\"direct-error\")) {\n        this.board.checkForErrors();\n      }\n      this.board.render();\n    });\n\n    $(\".sudoku-cell\").on(\"click\", (e) => {\n      this.selectedCell.removeClass(\"selected\");\n      this.selectedCell = $(e.currentTarget);\n      this.selectedId = parseInt(this.selectedCell.attr('id'));\n      this.selectedCell.addClass(\"selected\");\n    });\n\n    document.addEventListener(\"keydown\", (e) => {\n      let num = parseInt(e.keyCode) - 48;\n      let cell = this.board.cells[parseInt(this.selectedCell.attr(\"id\"))];\n      if (num >= 1 && num <= 9) {\n        if (cell.isGiven) {return;}\n        if (e.shiftKey) {\n          cell.value = 0;\n          cell.valueVisible = false;\n          cell.possibles[num - 1] = !cell.possibles[num - 1];\n          // for (let i = 0, len = cell.possibles.length; i < len; i++) {\n          //   if (cell.possibles[i]) {return;}\n          // }\n          // cell.valueVisible = true;\n        } else {\n          cell.valueVisible = true;\n          cell.possibles = [false,false,false,false,false,false,false,false,false];\n          cell.currentValue = num;\n        }\n        this.board.render();\n      } else if (e.keyCode === 37 && this.selectedId % 9 !== 0) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId - 1}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 39 && this.selectedId % 9 !== 8) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId + 1}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 38 && Math.floor(this.selectedId / 9) !== 0) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId - 9}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 40 && Math.floor(this.selectedId / 9) !== 8) {\n        this.selectedCell.removeClass(\"selected\");\n        this.selectedCell = $(`#${this.selectedId + 9}`);\n        this.selectedId = parseInt(this.selectedCell.attr('id'));\n        this.selectedCell.addClass(\"selected\");\n      } else if (e.keyCode === 8 || e.keyCode === 32 || e.keyCode === 48) { //delete value\n        if (cell.isGiven) {return;}\n        cell.currentValue = 0;\n        if (cell.valueVisible) {\n          cell.valueVisible = false;\n        } else {\n          cell.possibles = [false,false,false,false,false,false,false,false,false];\n        }\n        this.board.render();\n        if (this.selectedCell.hasClass(\"direct-error\")){\n          this.board.checkForErrors();\n        }\n      }\n    });\n\n    document.addEventListener(\"dragstart\",(e) => {\n      let target = this.isTargetInClass(e, \"number-button\");\n      if (target === null) {return;}\n      let cell = this.board.cells[parseInt($(e.target).attr(\"id\"))];\n      this.selectedButton.removeClass(\"selected\");\n      this.selectedButton = $(target);\n      // this.selectedButton.addClass(\"selected\");\n      // let draggable = $(document.createElement(\"div\"));\n      // draggable.attr(\"id\",\"draggable-tile\");\n      // draggable.html(target.innerText);\n      // $(\"body\").append(draggable);\n    });\n\n    document.addEventListener(\"drag\", (e) => {\n      e.preventDefault();\n      $(\"#draggable-tile\").css({\"top\": e.clientY, \"left\": e.clientX});\n    });\n\n    document.addEventListener(\"dragend\", (e) => {\n      $(\"#draggable-tile\").remove();\n    });\n\n\n    $(\".sudoku-cell\").on(\"dragover\", this.dragOver);\n    $(\".sudoku-cell\").on(\"dragenter\", this.dragEnter);\n    $(\".sudoku-cell\").on(\"drop\", this.drop);\n    $(\".sudoku-cell\").on(\"dragleave\", this.dragLeave);\n\n    this.board = new SudokuBoard();\n\n\n  }\n\n  setUpSudoku() {\n    $(\"#board\").children().remove();\n    let gameSpace = $(document.createElement(\"main\"));\n    gameSpace.attr(\"id\", \"game-space\");\n    $(\"#board\").append(gameSpace);\n    this.setUpGrid();\n    this.setUpNumberPanel();\n    this.setUpOptionsPanel();\n    this.gridProportions();\n  }\n\n  setUpGrid() {\n    let grid = $(document.createElement(\"div\"));\n    grid.attr(\"id\", \"grid\");\n    for (let i = 0; i < 9; i++) {\n      let box = $(document.createElement(\"div\"));\n      for (let j = 0; j < 9; j++) {\n        let cell = $(document.createElement(\"div\"));\n        let possibilities = $(document.createElement(\"div\"));\n        possibilities.addClass(\"sudoku-cell-possibilities\");\n        for (let k = 0; k < 9; k++) {\n          let possible = $(document.createElement(\"div\"));\n          possible.addClass(\"sudoku-cell-possibility\");\n          let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n          possible.attr('id',`${id}-${k}`);\n          possibilities.append(possible);\n        }\n        // possibilities.attr('id',`possibilities-${id}`);\n        cell.append(possibilities);\n        cell.addClass(\"sudoku-cell\");\n        let id = (Math.floor(i / 3) * 27) + ((i % 3) * 3) + (Math.floor(j / 3) * 9) + (j % 3);\n        cell.attr('id',`${id}`);\n        box.append(cell);\n      }\n      box.addClass(\"sudoku-box\");\n      grid.append(box);\n    }\n    $(\"#game-space\").append(grid);\n  }\n\n  setUpNumberPanel() {\n    // if( !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {\n    //  return;\n    // }\n    let numberPanel = $(document.createElement(\"div\"));\n    numberPanel.attr(\"id\", \"number-panel\");\n    let number;\n    for (let i = 0; i < 10; i++) {\n      number = $(document.createElement(\"div\"));\n      number.addClass(\"number-button\");\n      number.attr(\"val\",`${(i + 1) % 10}`);\n      number.attr(\"draggable\",true);\n      number.text(`${ (i + 1) % 10}`);\n      if ( i === 9) {\n        number.text(``);\n      }\n      numberPanel.append(number);\n    }\n    $(\"#game-space\").append(numberPanel);\n  }\n\n  gridProportions() {\n    let side;\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n      side =  Math.max(Math.floor(Math.min(window.screen[\"availHeight\"] * 0.8, window.screen[\"availWidth\"] * 0.75)), 250);\n    } else {\n      side =  Math.max(Math.floor(Math.min($(window).height() * 0.8, $(window).width() * 0.9)), 350);\n    }\n    side -= (side % 9);\n    $(\"#grid\").css({\"height\": side, \"width\": side});\n    $(\"#number-panel\").css({\"height\": side, \"width\": Math.floor(0.1 * side)});\n    $(\".sudoku-box\").css({\"font-size\": Math.floor(side * 0.085)});\n    $(\".sudoku-cell-possibility\").css({\"font-size\": Math.floor(side * 0.03)});\n    $(\".number-button\").css({\"font-size\": Math.floor(side * 0.08)});\n    // if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {\n     $(\".option-button\").css({\"width\": Math.floor((side + Math.floor(side * 0.08) + 42) / 4)});\n   // } else {\n   //   $(\"#options-panel\").css({\"padding-left\": 20});\n   //   $(\".option-button\").css({\"width\": Math.floor((side + 10) / 4)});\n   // }\n    // $(\"#options-panel\").css({\"margin-left\": $(\"#grid\").offset()[\"left\"]});\n  }\n\n  setUpOptionsPanel() {\n    let optionsPanel = $(document.createElement(\"div\"));\n    optionsPanel.attr(\"id\", \"options-panel\");\n    let option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"new-puzzle-button\");\n    option.html(\"NEW\");\n    option.on(\"click\", this.newPuzzle);\n    option.on(\"touchend\", this.newPuzzle);\n    optionsPanel.append(option);\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"clear-button\");\n    option.html(\"CLEAR\");\n    option.on(\"click\", () => (this.board.clear(false)));\n    option.on(\"touchend\", () => (this.board.clear(false)));\n    optionsPanel.append(option);\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"hint-button\");\n    option.html(\"HINT\");\n    optionsPanel.append(option);\n    option.on(\"click\", () => (this.board.hint()));\n    option.on(\"touchend\", () => (this.board.hint()));\n    option = $(document.createElement(\"div\"));\n    option.addClass(\"option-button\");\n    option.attr(\"id\", \"check-submit-button\");\n    option.html(\"CHECK\");\n    option.on(\"click\", this.check);\n    option.on(\"touchend\", this.check);\n    optionsPanel.append(option);\n    $(\"#board\").append(optionsPanel);\n  }\n\n  newPuzzle() {\n    this.board.clear(true);\n    this.board.makeGame();\n    $(\"#time-display\").remove();\n    window.scroll({\"top\": 0, \"behavior\": \"smooth\"});\n  }\n\n  check() {\n    if (this.board.checkForErrors()) {\n      if (this.board.isFull()) {\n        for (let i = 0, len = this.board.cells.length; i < len; i++) {\n          $(`#${i}`).addClass(\"solved\");\n        }\n        this.totalTime = Date.now() - this.board.startTime;\n        this.makeTimeDisplay();\n      } else {\n        $(\".sudoku-cell\").addClass(\"green-text\");\n        $(\".sudoku-box\").addClass(\"green-text\");\n        $(\"#grid\").addClass(\"green-text\");\n        setTimeout(() => {\n          $(\".sudoku-cell\").removeClass(\"green-text\");\n          $(\".sudoku-box\").removeClass(\"green-text\");\n          $(\"#grid\").removeClass(\"green-text\");\n        }, 250);\n      }\n    }\n  }\n\n  makeTimeDisplay() {\n    let timeDisplay = $(document.createElement(\"div\"));\n    timeDisplay.attr(\"id\", \"time-display\");\n    timeDisplay.html(`Your time is ${this.totalTime}`);\n    $(\"#board\").append(timeDisplay);\n    document.getElementById(\"time-display\").scrollIntoView({\"behavior\": \"smooth\"});\n  }\n\n  isTargetInClass(e, className) {\n    let target = e.target;\n    while (target.parentElement !== null) {\n      if (target.className === className) {\n        return target;\n      }\n      target = target.parentElement;\n    }\n    return null;\n  }\n\n  dragOver(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let target = $(e.target);\n    this.selectedCell.removeClass(\"selected\");\n    this.selectedCell = target;\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n    this.selectedCell.addClass(\"selected\");\n  }\n\n  dragLeave(e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  dragEnter(e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  drop(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let target = $(e.target);\n    let cell = this.board.cells[parseInt(target.attr(\"id\"))];\n    if (!cell.isGiven) {\n      let num = parseInt(this.selectedButton.attr(\"val\"));\n      cell.valueVisible = true;\n      cell.possibles = [false,false,false,false,false,false,false,false,false];\n      cell.currentValue = num;\n      if (num === 0 && target.hasClass(\"direct-error\")) {\n        this.board.checkForErrors();\n      }\n      this.board.render();\n    }\n    this.selectedCell = target;\n    this.selectedId = parseInt(this.selectedCell.attr('id'));\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 0\n// module chunks = 0","// import $ from 'jquery';\n\nimport * as util from './util';\n\nclass SudokuBoard {\n  constructor() {\n    this.boxes = [];\n    this.cells = [];\n    for (let i = 0; i < 9; i++) {\n      this.boxes.push(new SudokuBox(i));\n    }\n    let boxIdx, sudokuCell;\n    for (let i = 0; i < 81; i++) {\n      sudokuCell = new SudokuCell(0, i, false);\n      this.cells.push(sudokuCell);\n      boxIdx = (Math.floor(i / 27) * 3) + Math.floor((i % 9) / 3);\n      sudokuCell.box = this.boxes[boxIdx];\n      this.boxes[boxIdx].cells.push(sudokuCell);\n    }\n    this.render = this.render.bind(this);\n    this.setup = this.setup.bind(this);\n    this.populate = this.populate.bind(this);\n    this.populateBoard = this.populateBoard.bind(this);\n    this.changeNeighborsPos = this.changeNeighborsPos.bind(this);\n    this.changeNeighborsPosStep = this.changeNeighborsPosStep.bind(this);\n    this.solve = this.solve.bind(this);\n    this.solveCycle = this.solveCycle.bind(this);\n    this.resolveAmbiguity = this.resolveAmbiguity.bind(this);\n    this.getLeastAmbiguousCell = this.getLeastAmbiguousCell.bind(this);\n    this.depopulate = this.depopulate.bind(this);\n    this.setCellPossibilities = this.setCellPossibilities.bind(this);\n    this.makeGame = this.makeGame.bind(this);\n    this.clear = this.clear.bind(this);\n    this.clearErrors = this.clearErrors.bind(this);\n    this.checkForErrors = this.checkForErrors.bind(this);\n    this.checkRowsOrColsForErrors = this.checkRowsOrColsForErrors.bind(this);\n    this.clearErrors = this.clearErrors.bind(this);\n    this.hint = this.hint.bind(this);\n    this.getUniqueId = this.getUniqueId.bind(this);\n\n    this.makeGame();\n  }\n\n  getUniqueId() {\n    let offset = this.cells.reduce((acc, el) => {return acc + el.currentValue;},0) % 9;\n    let arr = [];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].isGiven) {\n        arr.push(((this.cells[i].currentValue + offset) % 9) + 1);\n      }\n      else {\n        arr.push(String.fromCharCode(((this.solvedGrid[i] + offset) % 9) + 1 + 64));\n      }\n    }\n    this.uniqueId = arr.join(\"\");\n  }\n\n  render() {\n    let cell, children, possibilities;\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      cell = $(`#${i}`);\n      for (let j = 0, posLen = this.cells[i].possibles.length; j < posLen; j++) {\n        $(`#${i}-${j}`).text(this.cells[i].possibles[j] ? j + 1 : \"\");\n      }\n      children = cell.children();\n      cell.text(this.cells[i].currentValue !== 0 && this.cells[i].valueVisible ? this.cells[i].currentValue : \"\");\n      cell.append(children);\n      if (this.cells[i].valueVisible) {\n        cell.children().removeClass(\"visible\");\n        cell.children().addClass(\"hidden\");\n      } else {\n        cell.children().removeClass(\"hidden\");\n        cell.children().addClass(\"visible\");\n      }\n    }\n  }\n\n  makeGame(){\n    this.gaveHint = false;\n    this.startTime = Date.now();\n    this.solvedGrid = this.populateBoard();\n    this.depopulate(60);\n    this.setCellPossibilities();\n    let puzzle = new Array(this.cells.length);\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      puzzle[i] = this.cells[i].currentValue;\n    }\n    puzzle = this.solve(puzzle);\n    this.setup(puzzle);\n    this.getUniqueId();\n    console.log(this.uniqueId);\n  }\n\n  hint() {\n    const blanks = [];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (!this.cells[i].isGiven && this.cells[i].currentValue === 0) {\n        blanks.push(i);\n      }\n    }\n    if (blanks.length === 0) {return;}\n    this.gaveHint = true;\n    const idx = blanks[Math.floor(Math.random() * blanks.length)];\n    this.cells[idx].currentValue = this.solvedGrid[idx];\n    this.cells[idx].isGiven = true;\n    $(`#${idx}`).addClass(\"given\");\n    this.render();\n  }\n\n  isFull() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (!this.cells[i].isGiven && this.cells[i].currentValue === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isSolved() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue !== this.solvedGrid[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  clear(givens) {\n    this.clearErrors();\n    for (let i = 0, len = this.cells.length; i <len; i++) {\n      if (givens || !this.cells[i].isGiven) {\n        this.cells[i].currentValue = 0;\n        this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n        this.cells[i].isGiven = false;\n        this.cells[i].inConflict = false;\n        $(`#${i}`).removeClass(\"given\");\n        $(`#${i}`).removeClass(\"solved\");\n      }\n    }\n    this.render();\n  }\n\n  clearErrors() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      $(`#${i}`).removeClass(\"indirect-error\");\n      $(`#${i}`).removeClass(\"direct-error\");\n    }\n  }\n\n  checkForErrors() {\n    this.clearErrors();\n    const cells = {};\n    const rows = this.checkRowsOrColsForErrors(cells, true);\n    const cols = this.checkRowsOrColsForErrors(cells, false);\n    const boxes = [];\n    let error;\n    for (let i = 0, len = this.boxes.length; i < len; i++) {\n      error = this.boxes[i].checkForErrors(cells);\n      if (error) {\n        boxes.push(i);\n      }\n    }\n\n    if (boxes.length === 0 && rows.length === 0 && cols.length === 0) {\n      return true;\n    }\n\n    for (let i = 0, rowTot = rows.length; i < rowTot; i++) {\n      for (let j = 0; j < 9; j++) {\n        this.cells[(rows[i] * 9) + j].toggleErrorColor(false);\n      }\n    }\n    for (let i = 0, colTot = cols.length; i < colTot; i++) {\n      for (let j = 0; j < 9; j++) {\n        this.cells[(9 * j) + cols[i]].toggleErrorColor(false);\n      }\n    }\n    for (let i = 0, len = boxes.length; i < len; i++) {\n      this.boxes[boxes[i]].toggleErrorColor();\n    }\n    Object.keys(cells).forEach((el) => {\n      $(`#${el}`).addClass(\"direct-error\");\n      $(`#${el}`).removeClass(\"indirect-error\");\n    });\n    return false;\n  }\n\n\n  checkRowsOrColsForErrors(cells, checkRows) {\n    let idx;\n    let errors = [];\n    // debugger\n    for (let i = 0, len = Math.sqrt(this.cells.length); i < len; i++) {\n      // debugger\n      let section = [false,false,false,false,false,false,false,false,false];\n      for (let j = 0; j < len; j++) {\n        if (checkRows) {idx = (i * 9) + j;}\n        else {idx = (j * 9) + i;}\n\n        if (this.cells[idx].currentValue === 0) {\n          continue;\n        } else if (section[this.cells[idx].currentValue - 1] !== false) {\n          cells[idx] = true;\n          cells[section[this.cells[idx].currentValue - 1]] = true;\n          errors.push(i);\n        } else {\n          section[this.cells[idx].currentValue - 1] = idx;\n        }\n      }\n    }\n    return errors;\n  }\n\n  setup(puzzle) {\n    for (let i = 0, len = puzzle.length; i < len; i++) {\n      if (puzzle[i] > 0) {\n        this.cells[i].isGiven = true;\n        $(`#${i}`).addClass(\"given\");\n      }\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n      this.cells[i].currentValue = puzzle[i];\n    }\n    this.render();\n  }\n\n  populateBoard() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [0,0,0,0,0,0,0,0,0];\n    }\n    while (true) {\n      if (this.populate(0)){\n        break;\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n    }\n    let solvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      solvedGrid[i] = this.cells[i].currentValue;\n    }\n    return solvedGrid;\n  }\n\n  populate(cellIdx) {\n    if (cellIdx >= 81) { return true;}\n\n    let indii = new Array(9);\n    let cell = this.cells[cellIdx];\n    for (let i = 0, len = indii.length; i < len; i++) {\n      indii[i] = i;\n    }\n    indii = util.randShuffle(indii);\n    for (let i = 0, len = cell.possibles.length; i < len; i++) {\n      let posIdx = indii[i];\n      if (cell.possibles[posIdx]) {\n        continue;\n      }\n\n      cell.currentValue = posIdx + 1;\n      this.changeNeighborsPosStep(cellIdx, posIdx, 1);\n\n      if (this.populate(cellIdx + 1)) {\n        return true;\n      } else {\n        this.changeNeighborsPosStep(cellIdx, posIdx, -1);\n        this.currentValue = 0;\n      }\n    }\n    return false;\n  }\n\n  depopulate(num) {\n    let idxs = [];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue !== 0){\n        idxs.push(i);\n      }\n    }\n    idxs = util.randShuffle(idxs);\n    for (let i = 0, len = Math.min(num, this.cells.length); i < len; i++) {\n      this.cells[idxs.pop()].currentValue = 0;\n    }\n  }\n\n  changeNeighborsPos(cellIdx, posIdx, value) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] = value;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] = value;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] = value;\n    }\n  }\n\n  changeNeighborsPosStep(cellIdx, posIdx, step) {\n    for (let j = 0, boxLen = this.cells[cellIdx].box.cells.length; j < boxLen; j++) {\n      this.cells[cellIdx].box.cells[j].possibles[posIdx] += step;\n    }\n    let startRow = Math.floor(cellIdx / 9) * 9;\n    for (let j = 0; j < 9; j++) {\n      this.cells[startRow + j].possibles[posIdx] += step;\n    }\n    let startCol = Math.floor(cellIdx % 9);\n    for (let j = 0; j < 9; j++) {\n      this.cells[(9 * j) + startCol].possibles[posIdx] += step;\n    }\n  }\n\n  setCellPossibilities() {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      this.cells[i].possibles = [true,true,true,true,true,true,true,true,true];\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n        this.cells[i].isGiven = true;\n        this.changeNeighborsPos(i, this.cells[i].currentValue - 1, false);\n      }\n    }\n  }\n\n  solve() {\n    //store initial state of grid\n    //call solve, and store the state that it returns\n    //if solve finished, reset to initial state and return true\n    //if unsolved, get cell with least ambiguity and cycle through guesses, calling solve after each\n    //if solve returns true only once, reset to inital state and return true\n    //else, reset to initial state and return false\n    let unsolvedGrid = new Array(this.cells.length);\n    for (let i = 0, len = unsolvedGrid.length; i < len; i++) {\n      unsolvedGrid[i] = this.cells[i].currentValue;\n    }\n    let grid = this.solveCycle(unsolvedGrid);\n    let cell, givenCell, possibles;\n    while (grid.includes(0)) {\n      cell = this.getLeastAmbiguousCell();\n      possibles = cell.getPossibles();\n      while (possibles.length > 1) {\n        givenCell = this.resolveAmbiguity(cell, possibles[0], Math.floor(Math.random() * 3));\n        unsolvedGrid[givenCell.idx] = possibles[0] + 1;\n        possibles = cell.getPossibles();\n      }\n\n      grid = this.solveCycle(grid);\n    }\n    return unsolvedGrid;\n    //alternatively, if solve is unfinished, get least ambiguous cell and fill in cells until unambigious\n    //these would also have to be filled in in the initial state\n  }\n\n  getLeastAmbiguousCell() {\n    let idx = 0;\n    while (this.cells[idx].currentValue > 0) {\n      idx += 1;\n    }\n    let cell = this.cells[idx];\n    let minPossibles = cell.getPossibles().length;\n    let possibles;\n    for (let i = 1, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) { continue; }\n      possibles = this.cells[i].getPossibles().length;\n      if (possibles < minPossibles) {\n        cell = this.cells[i];\n        minPossibles = possibles;\n      }\n    }\n    return cell;\n  }\n\n  resolveAmbiguity(cell, num, dir = 0) {\n    let targetCell;\n    if ( dir === 0) { // get cell from box\n      for (let i = 0, len = cell.box.cells.length; i < len; i++) {\n        if (this.solvedGrid[cell.box.cells[i].idx] === num + 1 ) {\n          targetCell = cell.box.cells[i];\n          break;\n        }\n      }\n    } else if (dir === 1) { //get cell from row\n      let startRow = Math.floor(cell.idx / 9) * 9;\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[startRow + i] === num + 1 ){\n          targetCell = this.cells[startRow+i];\n          break;\n        }\n      }\n    } else { //get cell from col\n      let startCol = Math.floor(cell.idx % 9);\n      for (let i = 0; i < 9; i++) {\n        if (this.solvedGrid[(9 * i) + startCol] === num + 1) {\n          targetCell = this.cells[(9 * i) + startCol];\n          break;\n        }\n      }\n    }\n    this.changeNeighborsPos(targetCell.idx, num, false);\n    targetCell.currentValue = num + 1;\n    targetCell.possibles = [false,false,false,false,false,false,false,false,false];\n    return targetCell;\n  }\n\n  solveCycle(state) {\n    let newState = state.slice();\n    let possiblesIdx;\n    let foundValue = true;\n    let solutions;\n    while (foundValue) {\n      foundValue = false;\n      for (let i = 0, len = this.cells.length; i < len; i++) {\n        if (this.cells[i].isGiven) {\n          continue;\n        }\n        possiblesIdx = this.cells[i].getPossibles();\n        if (possiblesIdx.length === 1) {\n          this.cells[i].currentValue = possiblesIdx[0] + 1;\n          this.cells[i].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(i, possiblesIdx[0], false);\n          foundValue = true;\n        }\n      }\n      for (let i = 0, len = this.boxes.length; i <len; i++) {\n        solutions = this.boxes[i].checkForSolutions();\n        for (let j = 0, solsLen = solutions.length; j < solsLen; j++) {\n          solutions[j][0].currentValue = solutions[j][1];\n          solutions[j][0].possibles = [false,false,false,false,false,false,false,false,false];\n          this.changeNeighborsPos(solutions[j][0].idx, solutions[j][1] - 1, false);\n          foundValue = true;\n        }\n      }\n    }\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      newState[i] = this.cells[i].currentValue;\n    }\n    return newState;\n    //cycle through grid, get all cells with one possible value\n    //set all selected cells to possible value\n    //repeat until no cells have single value or solved\n  }\n}\n\nclass SudokuBox {\n  constructor(idx) {\n    this.idx = idx;\n    this.cells = [];\n    this.box = null;\n\n    this.checkForSolutions = this.checkForSolutions.bind(this);\n    this.checkForErrors = this.checkForErrors.bind(this);\n    this.toggleErrorColor = this.toggleErrorColor.bind(this);\n  }\n\n  checkForErrors(cells) {\n    const nums = [false, false, false, false, false, false, false, false, false];\n    let errors = false;\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue === 0) {\n        continue;\n      } else if (nums[this.cells[i].currentValue - 1] !== false) {\n        cells[this.cells[i].idx] = true;\n        cells[nums[this.cells[i].idx]] = true;\n        errors = true;\n      } else {\n        nums[this.cells[i].currentValue - 1] = this.cells[i].idx;\n      }\n    }\n    return errors;\n  }\n\n  toggleErrorColor(toggleOn = true) {\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (toggleOn) {\n        $(`#${this.cells[i].idx}`).addClass(\"indirect-error\");\n        $(`#${this.cells[i].idx}`).addClass(\"indirect-error\");\n      } else {\n        $(`#${this.cells[i].idx}`).removeClass(\"indirect-error\");\n        $(`#${this.cells[i].idx}`).removeClass(\"indirect-error\");\n      }\n    }\n  }\n\n  checkForSolutions() {\n    let nums = [0,0,0,0,0,0,0,0,0];\n    for (let i = 0, len = this.cells.length; i < len; i++) {\n      if (this.cells[i].currentValue > 0) {\n        nums[this.cells[i].currentValue - 1] = 1;\n      }\n    }\n    let blanks = [];\n    for (let i = 0, len = nums.length; i < len; i++) {\n      if (!nums[i]){\n        blanks.push(i);\n      }\n    }\n    let solutions = [];\n    let cell;\n    for (let i = 0, len = blanks.length; i < len; i++) {\n      cell = null;\n      for (let j = 0, cellsLen = this.cells.length; j < cellsLen; j++) {\n        if (this.cells[j].possibles[blanks[i]]) {\n          if (cell !== null) {\n            cell = -1;\n            break;\n          }\n          cell = this.cells[j];\n        }\n      }\n      if (cell !== -1 && cell !== null) {\n        solutions.push([cell, blanks[i] + 1]);\n      }\n    }\n    return solutions;\n    //will get all missing nums, and insert them if they can only be put in one place\n  }\n}\n\nclass SudokuCell {\n  constructor(value = 0, idx, isGiven) {\n    this.currentValue = value;\n    this.valueVisible = true;\n    this.idx = idx;\n    this.isGiven = isGiven;\n    this.inConflict = false;\n    this.possibles = [false,false,false,false,false,false,false,false,false];\n\n    this.togglePossible = this.togglePossible.bind(this);\n    this.getPossibles = this.getPossibles.bind(this);\n    this.toggleErrorColor = this.toggleErrorColor.bind(this);\n  }\n\n  togglePossible(idx) {\n    this.possibles[idx] = !this.possibles[idx];\n  }\n\n  getPossibles() {\n    let possiblesIdx = [];\n    for (let i = 0, len = this.possibles.length; i < len; i++) {\n      if (this.possibles[i]) {\n        possiblesIdx.push(i);\n      }\n    }\n    return possiblesIdx;\n  }\n\n  toggleErrorColor(direct, toggleOn = true) {\n    if (toggleOn) {\n      if (direct) {\n        $(`#${this.idx}`).addClass(\"direct-error\");\n        $(`#${this.idx}`).removeClass(\"indirect-error\");\n      } else {\n        $(`#${this.idx}`).addClass(\"indirect-error\");\n      }\n    } else {\n      $(`#${this.idx}`).removeClass(\"direct-error\");\n    }\n  }\n}\n\n\nexport default SudokuBoard;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/sudoku.js\n// module id = 1\n// module chunks = 0","export const randShuffle = (array) => {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  while (0 !== currentIndex) {\n\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n};\n\nexport const programaticShuffle = (arr, sidx = 0, eidx = arr.length - 1) => {\n  if (sidx >= eidx) return;\n  let mid = Math.floor((sidx + eidx) / 2);\n  shuffleHelper(arr, sidx, eidx);\n  programaticShuffle(arr, sidx, mid);\n  programaticShuffle(arr, mid + 1, eidx);\n};\n\n\nexport const shuffleHelper = (arr,sidx, eidx) => {\n  let mid = Math.floor((sidx + eidx) / 2);\n  let base, midHolder;\n  if ((eidx - sidx) % 2 === 0) {\n    base = mid;\n    midHolder = arr[mid];\n  } else {\n    base = mid + 1;\n    midHolder = null;\n  }\n  let count = 0;\n  let c;\n  while (sidx + count < base) {\n    c = arr[mid + 1 + count];\n    arr[base + count] = arr[sidx + count];\n    arr[sidx + count] = c;\n    count += 1;\n  }\n  if (midHolder) arr[eidx] = midHolder;\n };\n\nexport const programaticDeshuffle = (arr, sidx = 0, eidx = arr.length - 1) => {\n  if (sidx >= eidx) return;\n  let mid = Math.floor((sidx + eidx) / 2);\n  programaticDeshuffle(arr, sidx, mid);\n  programaticDeshuffle(arr, mid + 1, eidx);\n  deshuffleHelper(arr, sidx, eidx);\n};\n\nexport const deshuffleHelper = (arr,sidx, eidx) => {\n  let mid = Math.floor((sidx + eidx) / 2);\n  let base, midHolder;\n  if ((eidx - sidx) % 2 === 0) {\n    base = 1;\n    midHolder = arr[mid];\n  } else {\n    base = 0;\n    midHolder = null;\n  }\n    let count = 0;\n  let c, l;\n  while (sidx + base + count <= mid) {\n    c = arr[mid + 1 + count];\n    arr[mid + 1 + count] = l ? l : arr[sidx + count];\n    if (midHolder) l = arr[sidx + count + base];\n    arr[sidx + count + base] = c;\n    count += 1;\n  }\n  if (midHolder) arr[sidx] = midHolder;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}